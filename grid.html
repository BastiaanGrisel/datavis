<html>
<head>
	<script src="d3.min.js" type="text/javascript"></script>
	<link rel="stylesheet" type="text/css" href="grid.css">
</head>
<body>
	<div class="flex_column">
		<div id="control_container">
			<select id="matches">
				{% for match in matches %}
				  <option value="{{match}}" {% if match == selected_match %}selected{% endif %}>{{match}}</option>
				{% endfor %}
			</select>
			<input type="number" id="start_time" value="{{selected_timepoint}}" min="{{min_time}}" max="{{max_time}}" />
			<input type="number" id="offset" value="0" />
		</div>
		<div id="svg_container">
		</div>
	</div>

	<script src="grid.js" type="text/javascript"></script>
	<script>
		// Populate grid
		var baseurl 	= "http://localhost/";

		var match_el 		= document.getElementById('matches'),
			start_time_el 	= document.getElementById('start_time'),
			offset_el		= document.getElementById('offset');

		getPlayerPositions();

        d3.select("#start_time").on("change", getPlayerPositions);	
        d3.select("#offset").on("change", getPlayerPositions);	
		
		/* Global variables */
		var start_time					= {{min_time}};
		var end_time 					= {{max_time}};
		var all_players;
		var red_team = [];
		var blue_team = [];
		var poi_player = [];

        function getPlayerPositions() { 
			var selected_match 				= parseInt(match_el.options[match_el.selectedIndex].value);
			var selected_start_time 		= parseInt(start_time_el.value);
			var selected_offset				= parseInt(offset_el.value);
			
			d3.json(baseurl + "locations/" + selected_match + "/" + selected_start_time + "/" + (selected_start_time+selected_offset), function (json) {
				tiles = [];
				all_players = [];
				red_team = [];
				blue_team = [];
				json.forEach(function(player) {
					if (player.tsync == selected_start_time) { /* Only select current timestamp */
						all_players.push(player);
						if(player.team == "dire") {
							if (!(include(red_team,player))) {
								red_team.push(player);
							}
						} else {
							if (!(include(blue_team,player))) {
								blue_team.push(player);
							}
						}
					}
					tiles.push(new Tile(player.x, player.y, player.team, player.player, player.tsync == selected_start_time))
				});
				findPOI(25, 2); /* players and teams are global, range 10, more then 3 players */
				updateGrid(tiles);
	        });
		}
		
		function findPOI(radius, treshhold){
			poi_player = [];
			all_players.forEach(function(player){
				battle = getPlayersInRadius(all_players, player, radius);
				if(battle.length > treshhold) {
					//console.log(dangerMeter(player,radius));
					if (dangerMeter(player,radius) > (4.5/5)*Math.sqrt(0.4)) { /* 1 additional player closer then 40% of the radius */
						if (!(include(poi_player,player))) {
							poi_player.push(player);
						}
					}
				}					
			});
			if(poi_player.length > 0) {
				console.log("Danger on players:");
				console.log(poi_player);
				poi = [];
				poi_player.forEach(function(p) {
					poi.push([p.x, p.y, p.team]);
				});
				poi = cluster(poi, radius);
			}
			return 0;
		}
		
		function cluster(poi, radius) {
			clustered_poi = [];
			cl_flag = false;
			poi.forEach(function(point) {
				other = poi.slice(0); //clone array
				if (other.length > 1) { //more then one point!
					other.splice(poi.indexOf(point),1); //remove point
					other.forEach(function(point2) { 
						if(point2[2] == point[2] && Math.sqrt((point2[0]-point[0])*(point2[0]-point[0])+(point2[1]-point[1])*(point2[1]-point[1])) < radius) { //if the same team and within radius
							cl_flag = true;
							new_point = [(point2[0]+point[0])/2,(point2[1]+point[1])/2,point[2]]; //take mean coordinate
							if (!(include_point(clustered_poi,new_point))) {
								clustered_poi.push(new_point); //add unique point
							}
						} else {
							if (!(include_point(clustered_poi,point))) {
								clustered_poi.push(point); 
							}
						}
					})
				} else { // no others
					if (!(include_point(clustered_poi,point))) {
						clustered_poi.push(point); //add unique point
					}
				}
			}) 
			if(cl_flag) {
				clustered_poi = cluster(clustered_poi, radius) //recursive call if there was clustering
			}
			return clustered_poi;
		}
		
		function dangerMeter(player,radius) {
			if(include(red_team, player)) {
				allies = red_team;
				enemies = blue_team;
			} else {
				allies = blue_team;
				enemies = red_team;
			}
			d_allies = 0;
			d_enemies = 0;
			allies.forEach(function(p) {
				d_allies += Math.sqrt(1-Math.min(playerDistance(player, p),radius)/radius);
			});
			enemies.forEach(function(p) {
				d_enemies += Math.sqrt(1- Math.min(playerDistance(player, p),radius)/radius);
			});
			return danger(d_allies, d_enemies);
		}
		
		function danger(dallies, denemies) {
			return (5/4.5)*(d_enemies - d_allies+0.5); /*enemies is positive, allies is negative danger, returns -5 to +5 danger, 0 is neutral */
		}
		
		function include(arr,obj) {
			return (arr.indexOf(obj) != -1);
		}
		
		function include_point(arr,p2) {
			found = false;
			arr.forEach(function(p) {
				if(p[0] == p2[0] && p[1] == p2[1] && p[2] == p2[2]){
					found = true;
				}
			});
			return found;
		}
		
		function getPlayersInRadius(players, player, radius) {
			inRadius = [];
			players.forEach(function(p){
				if (playerDistance(p,player) < radius) {
					inRadius.push(p)
				}
			});
			return inRadius;
		}
		
		function playerDistance(p1, p2){
			return Math.sqrt(Math.pow(p1.y-p2.y,2)+Math.pow(p1.x-p2.x,2)); /* Absolute distance */
		}

        d3.select("#matches").on("change", function(){ 
			var selected_match = parseInt(match_el.options[match_el.selectedIndex].value);

			d3.json(baseurl + "timepoints/" + selected_match, function (json) {
				start_time_el.value = d3.min(json);
				start_time_el.min   = d3.min(json);
				start_time_el.max   = d3.max(json);

				getPlayerPositions();
	        });
        });	
	</script>
</body>
</html>